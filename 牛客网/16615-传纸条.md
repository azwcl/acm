## 题目描述：
小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。  

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。  

还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。  

## 输入格式:
输入第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1<=m,n<=50）。  
接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。

## 输出格式:
输出共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

## 数据范围:
30%的数据满足：1<=m,n<=10  
100%的数据满足：1<=m,n<=50

## 输入样例:
```
3 3
0 3 9
2 8 5
5 7 0
```

## 输出样例:
```
34
```

## 题目来源:
牛客网：https://ac.nowcoder.com/acm/problem/16615  

## 算法标签:
动态规划

## 记录时间:
azwcl : 2019-11-17 9:45 CSDN  
azwcl : 2021-04-13 9:05 

## 思路:
本题进行分析之后，我们知道，我们就是要寻找一条好心值最大的往返路线。
这样子一来，我们很轻松的可以列出动态规划方程
```cpp
dp[x][y] = max(dp[x-1][y],dp[x][y-1]) + map[x][y];
```
这样子，我们可以很好的列出动态规划方程。因为我只能向上或者向下去走，所以说，我走到这一点时候的好心值最大的时候就是我上一点所走的好心值最大的时候加上我这点的好心值即可。这就是我这点的最大好心值。上一点，由于只可以向上和向下走，所以说，上一点就是我左边的点或者上面的点。这就是可以列出我们的动态规划方程。

这样一来，我们来思考我们如果去写这一题。本题难就难在我不仅要知道去的时候的好心值最大的时候，也需要求出回来的时候好心值最大的时候。
在开始的时候，我进行计算，发现我无法利用普通的方法去算出结果，也就是按照先找出去的路径再找出回来的路径，我无法计算，这个时候求助了网上的度娘，我知道了另一种写法。
我们可以不去按照题目的意思进行计算，我们可以换个思路去进行思考该问题，也就是说，我们为什么要考虑往返呢？只要两条不相同的路径即可，最后要求这两条路径上的好心值和是最大的即可，==那能不能一开始的时候传两张纸条呢？要求这两张纸条去走不相同的路线即可。== 这样传递的两张纸条所走的路径其实实际上和题目所要求的走的路径是一样一样的。

题目的思路进行确定，现在我们可以思考解题，这道题目还有一个重要的思想，就是阶段性。也就是说，我们走的时候，第一张纸条走一步，第二张纸条也要走一步，不能说，第一张纸条走到终点的时候，一回头看，发现第二张纸条还在起点的位置睡觉呢。所以说，一定要考虑到一起走的问题。

我们在解决一张纸条传送到终点的时候，使用二维数组去记录，那么相应的，我们两张纸条去走的话，使用者四维数组去记录。
我们知道有着四种情况：
	1.第一张纸条从上面走来，第二张纸条从上面走来；
	2.第一张纸条从上面走来，第二张纸条从左面走来；
	3.第一张纸条从左面走来，第二张纸条从上面走来；
	4.第一张纸条从左面走来，第二张纸条从左面走来；
这样子，可以列出动态规划方程
```cpp
int tmp1 = max(dp[x1-1][y1][x2-1][y2],dp[x1-1][y1][x2][y2-1]);
int tmp2 = max(dp[x1][y1-1][x2-1][y2],dp[x1][y1-1][x2][y2-1]);
int maxHao = max(tmp1,tmp2);
```
计算出来，他们上一步的时候最大的好心值是多少，然后我们再将他的好心值加上这两张纸条走到的位置的时候的好心值，就是我们走到这一点的最大好心值.
```
dp[x1][y1][x2][y2] = maxHao + map[x1][y1] + max[x2][y2];
```
这个时候我们加上了这一点的好心值，但是如果我们将这一点计算了两次的话我们岂不是重复计算了吗？没有关系，我们可以进行判断，判断是否重复计算，是的话，我们只需要减去这一点的好心值即可，但我们减去了这一点的好心值的话，岂不是我们就默认了重复走的路径了吗？其实不然，因为，两张纸条我走了两个阶段的话，我们本来可以加上四个格子的好心值，现在就变成了三个格子的好心值，那么是不是三个格子一定比不上四个格子的？所以，下一步计算好心值的时候，这三个格子的，还会是最大的好心值吗？不会，所以计算下一个格子的时候我也不会加上你了。  
```cpp
if(x1 == x2 && y1 == y2){
  dp[x1][y1][x2][y2] -= a[x1][y2];
}
```
这是判断重复的，并减去它，其实我也可以开始的时候只加上一个格子的好心值，然后发现两个坐标不相等的时候，我再度加上另一个纸条的走到位置的好心值。

## AC代码:
```cpp
#include <iostream>
using namespace std;
const int N = 55;
int map[N][N], dp[N][N][N][N], res = 0, m , n;
int main()
{
    scanf("%d %d", &m, &n);
    
    // input
    for(int i = 1; i <= m; ++i)
        for(int j = 1; j <= n; ++j)
            scanf("%d", &map[i][j]);
    
    // 计算dp
    for(int i = 1; i <= m; ++i)
        for(int j = 1; j <= n; ++j)
            for(int k = 1; k <= m; ++k)
                for(int z = 1; z <= n; ++z)
                {
                    dp[i][j][k][z] = max(max(dp[i-1][j][k-1][z], dp[i-1][j][k][z-1]), max(dp[i][j-1][k-1][z],dp[i][j-1][k][z-1])) + map[i][j];
                    if(i != k || j != z) dp[i][j][k][z] += map[k][z]; //不重复加上
                }
    
    cout << dp[m][n][m][n];
    
    return 0;
}
```