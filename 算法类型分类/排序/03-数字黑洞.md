## 题目描述：
给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。  
例如，我们从6767开始，将得到
```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
```
## 输入格式:
输入给出一个 (0,10<sup>​4</sup>) 区间内的正整数 N。

## 输出格式:
如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。  

## 数据范围:

## 输入样例:
```
6767
```

## 输出样例:
```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
```

## 题目来源:
PAT: https://pintia.cn/problem-sets/994805260223102976/problems/994805302786899968

## 算法标签:
排序，简单练习，

## 记录时间:
azwcl : 2021-03-28 9:21

## 思路:
数字分开，进行排序，再组合即可

## AC代码:
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

// 分割整数，进行存储
void resolution(int n, int arr[]){
    int index = 0;
    while(index < 4){
        arr[index++] = n%10;
        n /= 10;
    }
    /**
     不用这个分割，是因为防止不足4位的数字进来，导致数组里面存着上次分割的数字。例如999进来，只会占三个位置。
    while(n != 0)
    {
        arr[index++] = n % 10;
        n /= 10;
    }
    */
}

int main()
{
    int n;
    cin >> n;
    int arr[4] = {0};
    resolution(n, arr);

    if(n % 1111 == 0)
    {
        printf("%04d - %04d = %04d\n", n, n, 0);
    }
    else
    {
        while(true)
        {
            sort(arr, arr + 4);

            int max = arr[0] * 1 + arr[1] * 10 + arr[2] * 100 + arr[3] * 1000;
            int min = arr[0] * 1000 + arr[1] * 100 + arr[2] * 10 + arr[3] * 1;
            int num = max - min;

            printf("%04d - %04d = %04d\n", max, min, num);

            if(num == 6174) break;
            else resolution(num, arr);
        }
    }



    return 0;
}
```