## 题目描述：
你玩过“拉灯”游戏吗？  
25 盏灯排成一个 5×5 的方形。  
每一个灯都有一个开关，游戏者可以改变它的状态。  
每一步，游戏者可以改变某一个灯的状态。  
游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。  
我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。  
下面这种状态  
```
10111
01101
10111
10000
11011
```
在改变了最左上角的灯的状态后将变成：  
```
01111
11101
10111
10000
11011
```
再改变它正中间的灯后状态将变成：  
```
01111
11001
11001
10100
11011
```
给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。  

## 输入格式:
第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。  
以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。  
每组数据描述了一个游戏的初始状态。  
各组数据间用一个空行分隔。  

## 输出格式:
一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。  
对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。  

## 数据范围:
0<n≤500  

## 输入样例:
```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

## 输出样例:
```
3
2
-1
```

## 题目来源:
ACWING : https://www.acwing.com/problem/content/97/  

## 算法标签:
递推，位运算，算法竞赛进阶指南

## 记录时间:
azwcl : 2020-03-09 8:51 CSDN  
azwcl : 2021-04-13 20:40  

## 思路:
1. 一个格子最多只能变色一次，因为变色两次后会恢复原状，所以只能变色一次  
2. 当第一行确定时，只能通过第二行去改变第一行状态，然后通过第三行改变第二行状态，以此类推   
3. 枚举第一行原因：如果不枚举第一行全部可能，就意味着固定了，不能找到最优解。


## AC代码:
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 10;
char map[N][N];
char copyMap[N][N];

void turn(int x, int y)
{
    map[x][y] ^= 1;
    map[x - 1][y] ^= 1;
    map[x + 1][y] ^= 1;
    map[x][y - 1] ^= 1;
    map[x][y + 1] ^= 1;
}

bool check()
{
    for(int i = 1; i <= 5; i++)
        for(int j = 1; j <= 5; j++)
            if(map[i][j] == '0') return false;
    
    return true;
}

int main()
{
    int n;
    cin >> n;
    while(n--)
    {
        for(int i = 1; i <= 5; i++) cin >> (copyMap[i] + 1);

        // 先枚举第一行情况，再通过第二行改变第一行状态
        int res = 7;

        for(int i = 0; i < 32; i++)
        {
            int cnt  = 0;

            memcpy(map, copyMap, sizeof(char)*N*N);
            for(int j = 0; j < 5; j++)
                if(i >> j & 1) turn(1, j + 1), cnt++;// 该数字二进制为 1， 改变状态

            // 通过下一行，影响上一行
            for(int x = 2; x <= 5; x++)
                for(int y = 1; y <= 5; y++)
                    if(map[x - 1][y] == '0') turn(x, y), cnt++;
                    
            // 检查
            if(check()) res = min(res, cnt);
        }

        if(res <= 6) cout << res << endl;
        else cout << -1 << endl;
    }


    return 0;
}
```